<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cassegrain Multi-Config Design Tool (Unified)</title>
    <meta name="description" content="Analytical Cassegrain solver with deterministic hybrid trace.">
    <style>
        /* * PROFESSIONAL DARK THEME - OPTICAL ENGINEERING STANDARD */
        :root {
            --bg-dark: #1e272e;
            --bg-panel: #2c3e50;
            --text-light: #ecf0f1;
            --accent-blue: #3498db;
            --accent-orange: #e67e22;
            --accent-red: #e74c3c;
            --accent-green: #2ecc71;
            --input-bg: #34495e;
            --input-border: #7f8c8d;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: #151b22;
            padding: 12px 20px;
            border-bottom: 2px solid var(--accent-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 { margin: 0; font-size: 1.2rem; font-weight: 600; letter-spacing: 0.5px; }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* SIDEBAR (INPUTS) */
        .sidebar {
            width: 320px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--input-border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .section-header {
            background-color: #1a252f;
            padding: 10px 15px;
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent-blue);
            border-bottom: 1px solid var(--input-border);
            border-top: 1px solid var(--input-border);
            margin-top: 10px;
        }
        .section-header:first-child { margin-top: 0; border-top: none; }

        .input-grid {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .input-group { position: relative; }
        label { font-size: 0.8rem; color: #bdc3c7; margin-bottom: 4px; display: block; }
        input[type="number"], input[type="text"], select {
            width: 100%;
            padding: 6px 8px;
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            color: white;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
        }
        input:focus, select:focus { outline: none; border-color: var(--accent-blue); }
        .unit { position: absolute; right: 8px; top: 22px; font-size: 0.75rem; color: #95a5a6; pointer-events: none; }

        .config-card {
            background-color: #34495e;
            border-left: 3px solid var(--accent-orange);
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 0 4px 4px 0;
        }

        .btn-group { display: flex; gap: 8px; padding: 0 15px 15px 15px; }
        button {
            flex: 1; padding: 6px; background-color: #1a252f; color: white;
            border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;
            font-size: 0.8rem; transition: 0.2s;
        }
        button:hover { background-color: var(--accent-blue); border-color: var(--accent-blue); }
        button.primary { background-color: var(--accent-green); border-color: var(--accent-green); font-weight:bold; }

        /* MAIN AREA (TABLE + SVG) */
        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--bg-dark);
        }

        /* UNIFIED TABLE */
        .table-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            border-bottom: 1px solid var(--input-border);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background-color: var(--bg-panel);
            border-radius: 4px;
            overflow: hidden;
        }
        th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #1e272e; }
        th { background-color: #1a252f; color: var(--accent-blue); position: sticky; top: 0; }
        td { font-family: 'Consolas', monospace; }
        .row-header { font-weight: bold; color: #bdc3c7; width: 220px; }
        .section-row td { background-color: #151b22; color: var(--accent-orange); font-weight: bold; text-transform: uppercase; font-size: 0.75rem; padding-top: 15px;}
        .warn-text { color: var(--accent-red); font-weight: bold; }
        .shift-text { color: var(--accent-green); font-weight: bold; }

        /* SVG CHART */
        .chart-container {
            height: 350px;
            position: relative;
            background-color: #151b22;
        }
        svg { width: 100%; height: 100%; cursor: grab; }
        svg:active { cursor: grabbing; }
        .chart-overlay {
            position: absolute; bottom: 10px; right: 10px;
            background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px;
        }
        
    </style>
</head>
<body>

<header>
    <div>
        <h1>Cassegrain Multi-Config Design Tool</h1>
        <span class="subtitle">Deterministic Hybrid Trace Solver (v5.0)</span>
    </div>
    <div class="btn-group" style="width: 400px; padding:0;">
        <button onclick="app.loadTestCase()">Load SMF Case</button>
        <button onclick="app.resetView()">Fit Chart</button>
        <button class="primary" onclick="app.saveSession()">Save Inputs</button>
    </div>
</header>

<div class="main-container">
    
    <!-- LEFT SIDEBAR: INPUTS -->
    <div class="sidebar">
        <div class="section-header">NOMINAL SYSTEM (Config 1)</div>
        <div class="input-grid">
            <div class="input-group">
                <label>Primary Aperture (D1)</label>
                <input type="number" id="in_D1" value="600"><span class="unit">mm</span>
            </div>
            <div class="input-group">
                <label>System EFL (Nominal)</label>
                <input type="number" id="in_EFL" value="3600"><span class="unit">mm</span>
            </div>
            <div class="input-group">
                <label>Primary Radius (R1)</label>
                <input type="number" id="in_R1" value="-1800" step="10"><span class="unit">mm</span>
            </div>
            <div class="input-group">
                <label>Secondary Obstruction (&epsilon;)</label>
                <input type="number" id="in_obs" value="0.30" step="0.01"><span class="unit">D2/D1</span>
            </div>
            <div class="input-group">
                <label>Nominal FoV</label>
                <input type="number" id="in_fov1" value="0.057" step="0.01"><span class="unit">deg</span>
            </div>
            <div class="input-group">
                <label>Design Wavelength</label>
                <input type="number" id="in_wave1" value="1055"><span class="unit">nm</span>
            </div>
            <div class="input-group">
                <label>Lens Aspect Ratio (CT/D)</label>
                <input type="number" id="in_ct_ratio" value="0.10" step="0.01"><span class="unit">Ratio</span>
            </div>
        </div>

        <div class="section-header" style="display:flex; justify-content:space-between;">
            <span>WIDE-FIELD MODES</span>
            <span style="cursor:pointer;" onclick="app.addConfig()">[+] Add</span>
        </div>
        <div class="input-grid" id="config-list" style="padding-top:5px;">
            <!-- Dynamic configurations injected here -->
        </div>
    </div>

    <!-- RIGHT WORKSPACE: TABLE & CHART -->
    <div class="workspace">
        
        <!-- UNIFIED DATA MATRIX -->
        <div class="table-container">
            <table id="results-table">
                <!-- Generated by JS -->
            </table>
        </div>

        <!-- INTERACTIVE CHART -->
        <div class="chart-container">
            <svg id="optical-canvas"></svg>
            <div class="chart-overlay">
                <label style="font-size:0.8rem; color:#bdc3c7;">Render:</label>
                <select id="vis-selector" style="font-size:0.8rem; padding:2px;" onchange="app.drawSystem(true)">
                    <!-- Generated by JS -->
                </select>
            </div>
        </div>

    </div>
</div>

<script>
"use strict";

const MATERIALS = {
    "SILICA": { n: 1.46008, B: [0.6961663, 0.4079426, 0.8974794], C: [0.004679148, 0.01351206, 97.93400] }, 
    "N-BK7":  { n: 1.51680, B: [1.03961212, 0.231792344, 1.01046945], C: [0.00600069867, 0.0200179144, 103.560653] },
    "N-SF11": { n: 1.78472, B: [1.73759695, 0.313747346, 1.89878101], C: [0.013188707, 0.0623068339, 155.23629] },
    "CALCIUM_FLUORIDE": { n: 1.43385, B: [0.5675888, 0.4710914, 3.8484723], C: [0.00252643, 0.01007833, 1200.5560] }
};

const Utils = {
    getRefractiveIndex: (matName, lambda_nm) => {
        if (!MATERIALS[matName]) return 1.5;
        const L = lambda_nm / 1000.0; 
        const L2 = L * L;
        const m = MATERIALS[matName];
        if(!m.B) return m.n; 
        const n2 = 1 + (m.B[0]*L2)/(L2-m.C[0]) + (m.B[1]*L2)/(L2-m.C[1]) + (m.B[2]*L2)/(L2-m.C[2]);
        return Math.sqrt(n2);
    },
    fmt: (num, dec=3) => num !== undefined && !isNaN(num) ? Number(num).toFixed(dec) : "N/A",
    degToRad: (deg) => deg * (Math.PI/180)
};

const app = (function() {
    
    let configs = [];
    let results = { c1: {}, wf: [] };
    let view = { x: -1000, y: -400, w: 2000, h: 800, drag: false, lx: 0, ly: 0 };
    
    const els = {};
    const inputs = ['D1', 'EFL', 'R1', 'obs', 'fov1', 'wave1', 'ct_ratio'];

    function init() {
        inputs.forEach(id => {
            els[id] = document.getElementById('in_' + id);
            els[id].addEventListener('input', debounce(solveSystem, 250));
        });
        
        const svg = document.getElementById('optical-canvas');
        svg.addEventListener('wheel', handleZoom, { passive: false });
        svg.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        
        loadSession(); 
    }

    function debounce(fn, ms) {
        let t; return function(...args) { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); };
    }

    // --- STATE MANAGEMENT ---
    function saveSession() {
        const state = {
            inputs: inputs.map(id => els[id].value),
            configs: configs
        };
        localStorage.setItem('cassegrain_design_v5', JSON.stringify(state));
        const btn = document.querySelector('.primary');
        const oldText = btn.innerText;
        btn.innerText = "Saved!";
        btn.style.backgroundColor = "#27ae60";
        setTimeout(() => { btn.innerText = oldText; btn.style.backgroundColor = ""; }, 1500);
    }

    function loadSession() {
        const saved = localStorage.getItem('cassegrain_design_v5');
        if (saved) {
            try {
                const state = JSON.parse(saved);
                inputs.forEach((id, i) => { if (state.inputs[i]) els[id].value = state.inputs[i]; });
                configs = state.configs;
                renderConfigs();
                return;
            } catch (e) { console.error("Session load failed", e); }
        }
        loadTestCase();
    }

    // --- CONFIG MANAGEMENT ---
    function renderConfigs() {
        const container = document.getElementById('config-list');
        container.innerHTML = '';
        configs.forEach((cfg, idx) => {
            container.innerHTML += `
                <div class="config-card">
                    <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                        <strong style="font-size:0.85rem; color:var(--accent-orange)">Config ${idx+2}</strong>
                        <span style="color:#e74c3c; cursor:pointer; font-size:0.8rem;" onclick="app.removeConfig(${idx})">Remove</span>
                    </div>
                    <div class="input-group">
                        <label>Target Mirror EFL</label>
                        <input type="number" onchange="app.updateCfg(${idx}, 'efl_target', this.value)" value="${cfg.efl_target}"><span class="unit">mm</span>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>FoV</label>
                        <input type="number" step="0.01" onchange="app.updateCfg(${idx}, 'fov', this.value)" value="${cfg.fov}"><span class="unit">deg</span>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>Wavelength</label>
                        <input type="number" onchange="app.updateCfg(${idx}, 'wave', this.value)" value="${cfg.wave}"><span class="unit">nm</span>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>Flattener Material</label>
                        <select onchange="app.updateCfg(${idx}, 'mat', this.value)">
                            ${Object.keys(MATERIALS).map(m => `<option value="${m}" ${cfg.mat===m?'selected':''}>${m}</option>`).join('')}
                        </select>
                    </div>
                </div>
            `;
        });
        solveSystem();
    }

    function addConfig() {
        configs.push({ efl_target: 2400, fov: 0.25, wave: 822, mat: 'SILICA' });
        renderConfigs();
    }

    function removeConfig(idx) {
        configs.splice(idx, 1);
        renderConfigs();
    }

    function updateCfg(idx, key, val) {
        configs[idx][key] = key === 'mat' ? val : parseFloat(val);
        solveSystem();
    }

    // --- HYBRID PARAXIAL SOLVER ---
    function solveSystem() {
        try {
            // 1. Parse Inputs
            const D1 = parseFloat(els.D1.value);
            const EFL = parseFloat(els.EFL.value);
            const R1 = parseFloat(els.R1.value); 
            const obs = parseFloat(els.obs.value);
            const fov1 = parseFloat(els.fov1.value);
            const wave1 = parseFloat(els.wave1.value);
            const ct_ratio = parseFloat(els.ct_ratio.value);

            const f1 = Math.abs(R1) / 2; 
            const m = EFL / f1;          
            const D2 = obs * D1;         

            // Nominal Layout (Config 1)
            const half_fov_rad = Utils.degToRad(fov1 / 2);
            const denom = 2 * Math.tan(half_fov_rad) - (D1 / f1);
            const L12 = (D2 - D1) / denom;
            
            if(L12 <= 0 || isNaN(L12)) throw new Error("Invalid geometry: Check Obstruction/EFL ratio.");

            const BFD = m * (f1 - L12);
            const u_nom = f1 - L12; 
            const f2 = 1 / ((1/BFD) - (1/u_nom));
            const R2 = 2 * f2; 
            const K2 = -Math.pow((m + 1)/(m - 1), 2); 

            results.c1 = { EFL, f1, m, D1, R1, K1: -1.0, D2, L12, BFD, R2, K2, wave: wave1, fov: fov1 };
            results.wf = [];

            // 2. Wide Field Iterations (Deterministic Solve)
            configs.forEach((cfg, idx) => {
                const wf = { ...cfg, id: idx+2 };
                
                wf.EFL_target = cfg.efl_target;
                wf.m_mirrors = wf.EFL_target / f1;
                
                // 2A. Solve Mirrors to hit EFL_target precisely
                const u_new = f2 * (1 - wf.m_mirrors) / wf.m_mirrors;
                wf.L12 = f1 - u_new;
                wf.dz = wf.L12 - L12;
                wf.BFD_geom = wf.m_mirrors * u_new;
                
                // 2B. Lens Geometry Configuration
                wf.d_lens = 15.0; // Fixed physical clearance from focus ensures stability
                const t_air = wf.BFD_geom - wf.d_lens;
                
                wf.n = Utils.getRefractiveIndex(cfg.mat, cfg.wave);
                const p_sum = (1 + Math.abs(wf.m_mirrors)) / (Math.abs(wf.m_mirrors) * f1);
                wf.R_lens = -1 * (wf.n - 1) / (wf.n * p_sum) * 3.5; 
                
                const u_m_img = -(D1/2) / wf.EFL_target;
                const y_m_lens = Math.abs(u_m_img * wf.d_lens);
                const h_img = Math.abs(wf.EFL_target) * Math.tan(Utils.degToRad(cfg.fov/2));
                const y_c_lens = Math.abs(h_img - ((h_img / wf.BFD_geom) * wf.d_lens)); 
                wf.D_lens = 2 * (y_m_lens + y_c_lens) * 1.05;
                
                wf.CT = wf.D_lens * ct_ratio;
                const semidiam = wf.D_lens / 2;
                const R_abs = Math.abs(wf.R_lens);
                wf.sag = (semidiam < R_abs) ? R_abs - Math.sqrt(R_abs*R_abs - semidiam*semidiam) : semidiam;
                wf.ET = wf.CT + wf.sag;

                // 2C. Exact Paraxial Trace for True Lens Impact
                const y1 = D1 / 2;
                const u2_p = -y1 / wf.EFL_target; // Slope after M2
                const y3 = -u2_p * wf.d_lens;     // Height at Lens Front
                
                const p1 = (wf.n - 1) / wf.R_lens; // Negative power
                const u3_p = (u2_p - y3 * p1) / wf.n; // Refraction into glass
                const y4 = y3 + u3_p * wf.CT;
                const u4_p = wf.n * u3_p;         // Refraction into air (plano)
                
                wf.EFL_true = -y1 / u4_p;
                const back_focal_length = -y4 / u4_p;
                wf.BFD_final = t_air + wf.CT + back_focal_length;
                wf.focal_shift = wf.BFD_final - wf.BFD_geom;

                // Vignetting
                const y_m_M2 = y1 * (1 - wf.L12/f1);
                const y_c_M2 = wf.L12 * Math.tan(Utils.degToRad(cfg.fov/2));
                wf.D2_req = 2 * (Math.abs(y_m_M2) + Math.abs(y_c_M2));
                wf.vignetted = wf.D2_req > D2;

                results.wf.push(wf);
            });

            renderTable();
            updateChartSelectors();
            drawSystem(true);

        } catch (e) {
            console.error(e);
            document.getElementById('results-table').innerHTML = `<tr><td class="warn-text">Error: ${e.message}</td></tr>`;
        }
    }

    // --- UNIFIED TABLE RENDERER ---
    function renderTable() {
        const c1 = results.c1;
        const wfs = results.wf;
        let html = `
            <thead>
                <tr>
                    <th>Design Parameter Matrix</th>
                    <th>Nominal (C1)</th>
                    ${wfs.map(w => `<th>WF Mode (C${w.id})</th>`).join('')}
                </tr>
            </thead>
            <tbody>
                <tr class="section-row"><td colspan="${2 + wfs.length}">System Specifications</td></tr>
                <tr><td class="row-header">Target Mirror EFL (mm)</td><td>${Utils.fmt(c1.EFL,1)}</td>${wfs.map(w => `<td>${Utils.fmt(w.EFL_target,1)}</td>`).join('')}</tr>
                <tr><td class="row-header shift-text">True Final EFL (Lensed)</td><td class="shift-text">${Utils.fmt(c1.EFL,1)}</td>${wfs.map(w => `<td class="shift-text">${Utils.fmt(w.EFL_true,1)}</td>`).join('')}</tr>
                <tr><td class="row-header">System F/#</td><td>${Utils.fmt(c1.EFL/c1.D1,2)}</td>${wfs.map(w => `<td>${Utils.fmt(w.EFL_true/c1.D1,2)}</td>`).join('')}</tr>
                <tr><td class="row-header">Wavelength (nm)</td><td>${c1.wave}</td>${wfs.map(w => `<td>${w.wave}</td>`).join('')}</tr>
                <tr><td class="row-header">Field of View (Deg)</td><td>${c1.fov}</td>${wfs.map(w => `<td>${w.fov}</td>`).join('')}</tr>
                
                <tr class="section-row"><td colspan="${2 + wfs.length}">Surf 2: Primary Mirror (M1)</td></tr>
                <tr><td class="row-header">Radius (mm)</td><td colspan="${1 + wfs.length}">${Utils.fmt(c1.R1,3)}</td></tr>
                <tr><td class="row-header">Conic</td><td colspan="${1 + wfs.length}">${Utils.fmt(c1.K1,3)}</td></tr>
                <tr><td class="row-header">Semi-Diameter (mm)</td><td colspan="${1 + wfs.length}">${Utils.fmt(c1.D1/2,2)}</td></tr>
                <tr><td class="row-header">Thickness to M2 (mm)</td><td>${Utils.fmt(-c1.L12,3)}</td>${wfs.map(w => `<td>${Utils.fmt(-w.L12,3)}</td>`).join('')}</tr>

                <tr class="section-row"><td colspan="${2 + wfs.length}">Surf 3: Secondary Mirror (M2)</td></tr>
                <tr><td class="row-header">Radius (mm)</td><td colspan="${1 + wfs.length}">${Utils.fmt(c1.R2,3)}</td></tr>
                <tr><td class="row-header">Conic</td><td colspan="${1 + wfs.length}">${Utils.fmt(c1.K2,3)}</td></tr>
                <tr><td class="row-header">Clear Semi-Diameter</td>
                    <td>${Utils.fmt(c1.D2/2,2)}</td>
                    ${wfs.map(w => `<td class="${w.vignetted ? 'warn-text' : ''}">${Utils.fmt(w.D2_req/2,2)} ${w.vignetted ? '(Vignettes!)':''}</td>`).join('')}
                </tr>
                <tr><td class="row-header" style="color:var(--accent-orange);">M2 Shift (Î”z) (mm)</td><td>0.000</td>${wfs.map(w => `<td style="color:var(--accent-orange);">${Utils.fmt(w.dz,3)}</td>`).join('')}</tr>
                <tr><td class="row-header">Thickness to Next (mm)</td><td>${Utils.fmt(c1.BFD,3)}</td>${wfs.map(w => `<td>${Utils.fmt(w.BFD_geom - w.d_lens, 3)}</td>`).join('')}</tr>

                <tr class="section-row"><td colspan="${2 + wfs.length}">Surf 4: Aspheric Corrector (Front)</td></tr>
                <tr><td class="row-header">Surface Type</td><td>-</td>${wfs.map(w => `<td style="color:var(--accent-green)">EVEN ASPHERE</td>`).join('')}</tr>
                <tr><td class="row-header">Radius (mm)</td><td>Infinity (Ignored)</td>${wfs.map(w => `<td>${Utils.fmt(w.R_lens,3)}</td>`).join('')}</tr>
                <tr><td class="row-header">Thickness (CT) (mm)</td><td>0 (Ignored)</td>${wfs.map(w => `<td>${Utils.fmt(w.CT,3)}</td>`).join('')}</tr>
                <tr><td class="row-header">Edge Thickness (mm)</td><td>-</td>${wfs.map(w => `<td>${Utils.fmt(w.ET,3)}</td>`).join('')}</tr>
                <tr><td class="row-header">Semi-Diameter (mm)</td><td>-</td>${wfs.map(w => `<td>${Utils.fmt(w.D_lens/2,2)}</td>`).join('')}</tr>
                <tr><td class="row-header">Glass Material</td><td>-</td>${wfs.map(w => `<td>${w.mat} (n=${Utils.fmt(w.n,4)})</td>`).join('')}</tr>

                <tr class="section-row"><td colspan="${2 + wfs.length}">Surf 5: Aspheric Corrector (Back)</td></tr>
                <tr><td class="row-header">Radius (mm)</td><td>Infinity</td>${wfs.map(w => `<td>Infinity (Plano)</td>`).join('')}</tr>
                <tr><td class="row-header">Thickness to Image (mm)</td><td>0</td>${wfs.map(w => `<td>${Utils.fmt(w.BFD_final - (w.BFD_geom - w.d_lens + w.CT), 3)}</td>`).join('')}</tr>

                <tr class="section-row"><td colspan="${2 + wfs.length}">Optical Focus Properties</td></tr>
                <tr><td class="row-header">True Final BFD (mm)</td><td>${Utils.fmt(c1.BFD,3)}</td>${wfs.map(w => `<td>${Utils.fmt(w.BFD_final,3)}</td>`).join('')}</tr>
                <tr><td class="row-header shift-text">Paraxial Focal Shift</td><td>0.000</td>${wfs.map(w => `<td class="shift-text">+${Utils.fmt(w.focal_shift,3)}</td>`).join('')}</tr>

                <tr class="section-row"><td colspan="${2 + wfs.length}">Zemax Export (Copy & Run ZPL)</td></tr>
                <tr><td colspan="${2 + wfs.length}"><textarea readonly onclick="this.select()" style="width:100%; height:120px; background:#111; color:#a2b9bc; border:1px solid #333; font-family:monospace; padding:5px;">${generateZPL()}</textarea></td></tr>
            </tbody>
        `;
        document.getElementById('results-table').innerHTML = html;
    }

    function generateZPL() {
        const c1 = results.c1;
        const wfs = results.wf;
        const D1 = c1.D1;
        const L12 = -1 * c1.L12; 
        const N_configs = wfs.length + 1;
        
        let zpl = `! Analytical Cassegrain Solution v5.0\n`;
        zpl += `SETSYSTEM 0, 0, ${D1}\nWAVELENGTH 1, ${c1.wave/1000}\nUNITS 0\n\n`;
        
        zpl += `INSERTSURFACE 1\nINSERTSURFACE 2\nINSERTSURFACE 3\nINSERTSURFACE 4\nINSERTSURFACE 5\nINSERTSURFACE 6\n`;
        zpl += `SURFACETYPE 2, STANDARD\nSETCRVT 2, ${1/c1.R1}\nSETCONI 2, -1.0\nSETTHIC 2, ${L12}\nSETGLAS 2, MIRROR\nSETSDIA 2, ${D1/2}\nCOMM 2, "M1"\n`;
        zpl += `SURFACETYPE 3, STANDARD\nSETCRVT 3, ${1/c1.R2}\nSETCONI 3, ${c1.K2}\nSETTHIC 3, ${c1.BFD}\nSETGLAS 3, MIRROR\nSETSDIA 3, ${c1.D2/2}\nCOMM 3, "M2"\n`;
        
        zpl += `! Config 1 has no lens\nSURFACETYPE 4, EVENASPH\nSETTHIC 4, 0\nCOMM 4, "LENS_FRONT"\n`;
        zpl += `SURFACETYPE 5, STANDARD\nSETTHIC 5, 0\nCOMM 5, "LENS_BACK"\nCOMM 6, "IMAGE"\n\n`;
        
        zpl += `INSERTMCO ${N_configs}\n`;
        
        zpl += `INSERTMCOPERAND 1, 0, "THIC", 2, 0, 0, 0\nSETMCOMONITOR 1, 1, ${L12}\n`;
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 1, ${i+2}, ${L12 + w.dz}\n`);

        zpl += `INSERTMCOPERAND 2, 0, "THIC", 3, 0, 0, 0\nSETMCOMONITOR 2, 1, ${c1.BFD}\n`;
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 2, ${i+2}, ${w.BFD_geom - w.d_lens}\n`);

        zpl += `INSERTMCOPERAND 3, 0, "WAVE", 1, 0, 0, 0\nSETMCOMONITOR 3, 1, ${c1.wave/1000}\n`;
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 3, ${i+2}, ${w.wave/1000}\n`);

        zpl += `INSERTMCOPERAND 4, 0, "IGNR", 4, 0, 0, 0\nSETMCOMONITOR 4, 1, 1\n`; 
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 4, ${i+2}, 0\n`);

        zpl += `INSERTMCOPERAND 5, 0, "IGNR", 5, 0, 0, 0\nSETMCOMONITOR 5, 1, 1\n`; 
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 5, ${i+2}, 0\n`);

        zpl += `INSERTMCOPERAND 6, 0, "CRVT", 4, 0, 0, 0\n`;
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 6, ${i+2}, ${1/w.R_lens}\n`);

        zpl += `INSERTMCOPERAND 7, 0, "THIC", 4, 0, 0, 0\n`;
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 7, ${i+2}, ${w.CT}\n`);

        zpl += `INSERTMCOPERAND 8, 0, "THIC", 5, 0, 0, 0\n`;
        wfs.forEach((w, i) => zpl += `SETMCOMONITOR 8, ${i+2}, ${w.BFD_final - (w.BFD_geom - w.d_lens + w.CT)}\n`);
        
        zpl += `! IMPORTANT: Set Surface 4 Conic (K) and 4th Order Term as Variables in Zemax\nUPDATE\n`;
        return zpl;
    }

    // --- VISUALIZATION ---
    function updateChartSelectors() {
        const sel = document.getElementById('vis-selector');
        sel.innerHTML = `<option value="1">Config 1 (Nominal)</option>`;
        results.wf.forEach(w => {
            sel.innerHTML += `<option value="${w.id}">Config ${w.id} (WF)</option>`;
        });
    }

    function drawSystem(forceFit = false) {
        if(!results.c1.EFL) return; 
        const canvas = document.getElementById('optical-canvas');
        canvas.innerHTML = '';
        
        const c1 = results.c1;
        const activeId = parseInt(document.getElementById('vis-selector').value);
        
        let L12 = c1.L12;
        let BFD = c1.BFD;
        let activeWF = null;

        if (activeId !== 1) {
            activeWF = results.wf.find(w => w.id === activeId);
            if(activeWF) {
                L12 = activeWF.L12;
                BFD = activeWF.BFD_final; 
            }
        }

        const M1_z = 0;
        const M2_z = -Math.abs(L12);
        const Img_z = M2_z + BFD;

        // M1
        const R1 = Math.abs(c1.R1);
        const sag1 = (c1.D1*c1.D1)/(8*R1);
        canvas.innerHTML += `<path d="M ${-sag1},${c1.D1/2} Q 0,0 ${-sag1},${-c1.D1/2}" stroke="#3498db" fill="none" stroke-width="4" vector-effect="non-scaling-stroke" />`;
        
        // M2
        const R2 = Math.abs(c1.R2);
        const sag2 = (c1.D2*c1.D2)/(8*R2);
        canvas.innerHTML += `<path d="M ${M2_z - sag2},${c1.D2/2} Q ${M2_z},0 ${M2_z - sag2},${-c1.D2/2}" stroke="#e67e22" fill="none" stroke-width="4" vector-effect="non-scaling-stroke" />`;

        // Lens
        if (activeWF) {
            const z_lens = M2_z + (activeWF.BFD_geom - activeWF.d_lens);
            const h = activeWF.D_lens / 2;
            const curve = activeWF.sag;
            const lensPath = `M ${z_lens + curve},${-h} Q ${z_lens},0 ${z_lens + curve},${h} L ${z_lens + activeWF.CT},${h} L ${z_lens + activeWF.CT},${-h} Z`;
            canvas.innerHTML += `<path d="${lensPath}" fill="rgba(46, 204, 113, 0.5)" stroke="#27ae60" vector-effect="non-scaling-stroke"/>`;
        }

        // Image Plane
        canvas.innerHTML += `<line x1="${Img_z}" y1="${-c1.D1/4}" x2="${Img_z}" y2="${c1.D1/4}" stroke="#bdc3c7" stroke-dasharray="5,5" vector-effect="non-scaling-stroke"/>`;

        // Rays
        const drawRay = (h_in) => {
            const y_m2 = h_in * (1 - Math.abs(L12)/c1.f1);
            const pts = `${M2_z - 500},${h_in} ${0},${h_in} ${M2_z},${y_m2} ${Img_z},0`;
            canvas.innerHTML += `<polyline points="${pts}" stroke="#f1c40f" fill="none" stroke-width="1.5" opacity="0.6" vector-effect="non-scaling-stroke"/>`;
        };
        drawRay(c1.D1/2);
        drawRay(-c1.D1/2);

        if(forceFit) {
            const pad = 150;
            view.x = M2_z - pad;
            view.y = -c1.D1/2 - pad;
            view.w = (Img_z - M2_z) + pad*2;
            view.h = c1.D1 + pad*2;
            updateViewBox();
        } else {
            updateViewBox();
        }
    }

    // --- PAN/ZOOM INTERFACE ---
    function handleZoom(e) {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 1.1 : 0.9;
        const cx = view.x + view.w/2;
        const cy = view.y + view.h/2;
        view.w *= factor; view.h *= factor;
        view.x = cx - view.w/2; view.y = cy - view.h/2;
        updateViewBox();
    }
    function handleMouseDown(e) { view.drag = true; view.lx = e.clientX; view.ly = e.clientY; }
    function handleMouseMove(e) {
        if (!view.drag) return;
        const svg = document.getElementById('optical-canvas');
        const r = svg.getBoundingClientRect();
        view.x -= (e.clientX - view.lx) * (view.w / r.width);
        view.y -= (e.clientY - view.ly) * (view.h / r.height);
        view.lx = e.clientX; view.ly = e.clientY;
        updateViewBox();
    }
    function handleMouseUp() { view.drag = false; }
    function updateViewBox() { document.getElementById('optical-canvas').setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`); }

    // --- TEST CASE ---
    function loadTestCase() {
        els.D1.value = 600;
        els.EFL.value = 3600; 
        els.R1.value = -1800; 
        els.obs.value = 0.30;
        els.fov1.value = 0.057; 
        els.wave1.value = 1055;
        els.ct_ratio.value = 0.10;

        configs = [
             { efl_target: 2400, fov: 0.25, wave: 822, mat: 'SILICA' },
             { efl_target: 2400, fov: 0.25, wave: 1807, mat: 'SILICA' }
        ];
        renderConfigs(); 
    }

    return { init, addConfig, removeConfig, updateCfg, drawSystem, loadTestCase, resetView: () => drawSystem(true), saveSession };
})();

window.addEventListener('DOMContentLoaded', app.init);
</script>
</body>
</html>
